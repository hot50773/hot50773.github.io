<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>使用策略模式實現前端表單驗證</title>
</head>

<body>
  <h2>策略模式的組成</h2>
  <ol>
    <li>策略集合：定義所有可實施的策略名稱和執行內容</li>
    <li>驗證器（抽像物件）：定義驗證器的功能<br>1. 註冊策略方法 <br>2. 根據已註冊的策略，執行驗證</li>
    <li>實做驗證：實例化一個表單驗證器，最终给客户端用的。</li>
  </ol>
  <h2>DEMO</h2>
  <form id="formRegist" action="">
    <input type="text" name="name" placeholder="name">
    <input type="text" name="password" placeholder="password">
    <input type="text" name="phone" placeholder="phone">
    <input type="text" name="email" placeholder="email">

    <input type="submit" value="Validate">
  </form>
  <div id="errorBox" style="background: #fafaff; color: palevioletred;"></div>
  <h4>Reference</h4>
  <ul>
    <li><a href="https://juejin.cn/post/6844903477986983943">掘金 - 探索两种优雅的表单验证——策略设计模式和 ES6 的 Proxy 代理模式</a></li>
  </ul>
  <script>
    function copyData (jsonData) {
      return JSON.parse(JSON.stringify(jsonData))
    }

    var form = document.querySelector('#formRegist')

    // 1.策略方法
    var strategies = {
      isNonEmpty(value, errorMsg) {
        return value === '' ?
          errorMsg : void 0
      },
      minLength(value, length, errorMsg) {
        return value.length < length ?
          errorMsg : void 0
      },
      isMobile(value, errorMsg) {
        return !/^1(3|5|7|8|9)[0-9]{9}$/.test(value) ?
          errorMsg : void 0
      },
      isEmail(value, errorMsg) {
        return !/^\w+([+-.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$/.test(value) ?
          errorMsg : void 0
      }
    }

    // 2.控制器
    /*Validator类*/
    class Validator {
      constructor() {
        this.cache = [] //保存校验规则
      }
      add(domInput, rules = ['minLength:6', 'isNonEmpty']) { // 針對特定的 dom 對象，註冊他專屬的驗證策略
        for (let rule of rules) {
          let strategyAry = rule.strategy.split(':') //例如['minLength',6]
          let errorMsg = rule.errorMsg //'用户名不能为空'

          this.cache.push(() => {
            var strategyArgs, name

            strategyArgs = copyData(strategyAry)
            name = strategyArgs.shift() // shift() 方法會移除並回傳陣列的第一個元素，也就是策略名稱
            strategyArgs.unshift(domInput.value) // unshift() 會新增一個或多個元素至陣列的開頭，也就是 input 值

            strategyArgs.push(errorMsg) // 新增 errorMsg 至陣列的結尾，[input.value, 6, errorMsg]

            // 最後 strategyAry 的格式為 [inputValue, ...otherArgs, errorMsg]
            return strategies[name].apply(this, strategyArgs)
          })
        }
      }
      start() { // 開始執行驗證
        for (let validatorFunc of this.cache) {
          let errorMsg = validatorFunc() //开始校验，并取得校验后的返回信息

          if (errorMsg) return errorMsg
        }

      }
    }

    // 3. 實例化
    var RegistValidator = new Validator()

    // 3.1 註冊驗證規則
    RegistValidator.add(form.name, [{
      strategy: 'isNonEmpty',
      errorMsg: '用户名不能为空！'
    }, {
      strategy: 'minLength:6',
      errorMsg: '用户名长度不能小于6位！'
    }])

    // 3.2 執行驗證
    form.addEventListener('submit', (e) => {
      e.preventDefault()

      var errMsg = RegistValidator.start()
      if (errMsg) {
        errorBox.innerText = errMsg
      }
    })

  </script>
</body>

</html>